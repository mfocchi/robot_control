\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{mathtools}

\usepackage{setspace}
\onehalfspacing

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{indentfirst}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newtheorem{corollary}{Corollary}

\newtheorem*{theorem*}{Theorem}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{example*}{Example}
\newtheorem*{definition*}{Definition}
\newtheorem*{remark*}{Remark}
\newtheorem*{corollary*}{Corollary}

%\usepackage{booktabs, caption, graphicx, float}
%\usepackage{subcaption}
%\captionsetup{tableposition=top,figureposition=bottom,font=small}

\usepackage{comment}
\usepackage{multirow}
\usepackage{array}

\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage[hidelinks]{hyperref}

\usepackage{geometry}
\geometry{a4paper, top=3cm,bottom=3cm,left=3cm,right=3cm,%
	heightrounded}
\usepackage{upgreek}
\usepackage{xparse}
\usepackage{listings}
\NewDocumentCommand{\codeword}{v}{%
	\texttt{\textcolor{black}{#1}}%
}

\newcommand{\prepos}[3]{${}_{\mathbf{#2}}{\mathbf{#1}}_{#3}$}
\newcommand{\preposm}[3]{{}_{\mathbf{#2}}{\mathbf{#1}}_{#3}}


%Dummy text
\usepackage{lipsum}

%Changing headers and footers
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\rhead{\textit{\thepage}}
\lhead{\textit{ Task Space Motion Control Lab}}

%For inserting the code
\usepackage{fancyvrb}

%For bold math symbols
\usepackage{bm}

%For multicolumns
\usepackage{multicol}

% Norm and abs delimiter
\usepackage{mathtools}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiterX{\norm}[1]{\lVert}{\rVert}{#1}

\setcounter{section}{-1}

% Argmin/Argmax
\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}

% Enumerate
\usepackage{enumitem}

% Code
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{etoolbox}

% Longtable
\usepackage{longtable}

% SI units
\usepackage{siunitx}
\sisetup{output-exponent-marker=\ensuremath{\mathrm{e}}}

% Colours in equations
\usepackage{xcolor}

\newcommand{\Rnum}{\mathbb{R}} % Symbol fo the real numbers set
\newcommand{\mat}[1]{\ensuremath{\begin{bmatrix}#1\end{bmatrix}}}	% matrix
\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}


\title{LAB 7: Admittance Control}
\author{Michele Focchi and Matteo Saveriano}
\date{}

\begin{document}
	\maketitle
	\noindent
	The goals of this assignment are:
	\begin{itemize}
		\item learning the basic procedure to design an admittance controller for the end-effector of a manipulator in contact with the environment with the purpose to control the interaction with a human.
		\item Implement an obstacle avoidance planning algorithm base on potential fields. 
	\end{itemize}
	
	\noindent
	Tools that we are going to be using in this lab (all open-source):
	\begin{itemize}
		\item Python programming (2.7)\footnote{https://docs.python.org/2.7/}
		\item Robot Operating System (ROS)\footnote{https://www.ros.org/}
		\item Gazebo \footnote{http://gazebosim.org/}
		\item Pinocchio Library for Rigid Body Dynamics Algorithms\footnote{https://github.com/stack-of-tasks/pinocchio}
		\item Locosim\footnote{https://github.com/mfocchi/locosim}
	\end{itemize}
	%
	%
	%\noindent
	In this assignment we will modify the set-point for the end-effector computed in previous labs, using an admittance model, to accommodate for an external force acting at the end-effector. An inverse kinematics scheme will map the new references into joint references. We will close the loop for tracking at the joint level. The implementation of and admittance control scheme is the only way to be able to  achieve safe interactions with industrial robots that accept only position (and not torque) references. Indeed, most of the times, industrial robots are not equipped with an inner torque loop, but with a (stiff) position loop at the low level, plus a 6 axis force sensor located at the end-effector. Differently from the approaches seen until now, that enable a safe interaction with any part of the robot, this approach allows the robot to be compliant (and safe) \textit{only} if the interaction occurs at the end-effector location, where we are able to \textit{sense} the force. 
	
\section{Preliminaries}
	The robot that we will use this time, is still the  Ur5 robot, but, differently from before, we will not integrate the dynamics by ourself with a forward Euler method,  but this task will be delegated to a simulator called Gazebo. An intermediate controller ( \codeword{ros_impedance_controller}) will receive the PD gains and the set-points (of desired joint positions and velocities) and feed-forwards for the torques generated by our Python node.
	The  \codeword{ros_impedance_controller} will either interface to the  Gazebo simulator or to the real robot. This has the big advantage of  allowing us to use the \textit{same} code in both situations, and safely test our algorithm before going on the real robot.\\

\textbf{1.1 Position Control - Constant Joint Reference}\\
Since the real prototype of the UR5 robot it does not accept desired torque command but only position and velocity commands, 
the first experience we are going to do is to create a constant set-point in position for our robot. 
Therefore, in the \codeword{params.yaml} configuration file, set \codeword{real_robot: True},   
\codeword{control_mode: point}, \codeword{control_type: position}.
Then, to check that everything works, set a constant reference for joint position equal $q^0=\mat{ 0.5& -1.0& 1.0& -1.7& -1.7& 0.0}^T$.
Note that the real robot might start in a different configuration and to avoid abrupt motions you need to implement a \textit{homing} procedure to drive smoothly the joints to  the  $q^0$ set-point. \\

\textbf{1.2 Position Control - Sinusoidal  Joint Reference.}\\
Now set a sinusoidal reference starting from the  $q^0$ configuration. Try to avoid to set too large amplitude in order to avoid hitting some obstacles. \\

\textbf{1.3 Position Control - Constant Cartesian Reference}\\
Now let's set a constant Cartesian position (expressed in the base frame, check the base frame axes) 
for the end-effector $p_e^d=\mat{-0.3&  0.5& -0.5}^T   $. Employ the inverse kinematics function implemented in L1-2.6 and solve the redundancy  setting a postural task $q^p = q_0$.\\

\textbf{1.4 Position Control - Constant Cartesian Reference and Orientation.}\\
In addition to the end-effector position, now we want also to specify a desired orientation with ${}_WR_e^d = eul2rot(\mat{-1.9& -0.5& -0.1})$.
In this case the task is 6D and there is no need of regularization or of a postural task, because the full Jacobian $J6 \in \Rnum^{6 \times 6}$ should we used. 
Note that the now we have to append also  the orientation error $e_o$  to $e_p$. This can be computed with the angle-axis approach or equivalent way as we did for the L3 lab: 

\begin{align}
e_o = {}_wR_e \text{logm}({}_wR_e^T {}_wR_e^d)
\end{align}


\textbf{1.5 Position Control - Polynomial trajectory}\\
If you implemented both 1.2 and 1.3 on the real robot, you will notice that the robot goes into protection mode because we are setting an abrupt change in the position set-point $q^d$ that goes from $q_0$ to $IK(p_e^d)$.
Taking inspiration from L1-2.5, design polynomial  trajectories (if you want you can create a class for this) for the end-effector Cartesian coordinates to go from the actual position ($FK(q^0)$) to $p_e^d$. You can start with a quintic polynomial and set zero initial /final velocity and accelerations. Note that only for the quintic it will be possible to enforce the accelerations. Do the implementation also for a cubic polynomial and compare the results.\\


\section{Admittance Control}
An admittance control framework requires two components: an \textit{admittance model} and an \textit{inverse kinematics} function.
The philosophy behind \textit{admittance} control is to change the end-effector position set-point in order to mimic a desired admittance at the end-effector. 
\footnote{Mechanical admittance is the reciprocal of impedance}. We recall that an admittance is a linear model that receives  as input a \textit{force} and 
outputs a displacement $\Delta p_e$ (or a velocity). Then, the displacement $\Delta p_e$ is added to the set-point creating a new reference for the end-effector $\tilde{p_e}^d = \Delta p_e + {p_e}^d$  that is mapped to joints references via an inverse kinematics function, as shown in figure \ref{fig:admittance}:\\

\begin{figure}[bht]
	\centering
	\includegraphics[width=8cm]{pics/admittanceControl.pdf}
	\caption{Block diagram for an admittance controller in the Cartesian space. FK(.) and IK(.) are the forward and inverse kinematics blocks, respectively, while G(s) is the admittance model.}
	\label{fig:admittance}
\end{figure}

\textbf{2.1 - Implement the admittance model }\\
We want to implement an admittance model that represents a \textit{linear} virtual spring and a \textit{linear} virtual damper at the end-effector.
The transfer function G(s) for this model in the Laplace domain is :



\begin{align}
\label{eq:tf}
\Delta p_e &= \frac{ F_{ext} }{K_d s + K_p}\\
G(s)& = \frac{\Delta p}{F_{ext}} = \frac{ 1 }{K_d s + K_p} \nonumber
\end{align}


Where the input is the contact force $F_{ext}\in \Rnum^3$ and the output the shift  $\Delta p_e\in \Rnum^3$ to be applied to the end-effector reference to emulate a virtual stiffness in response to  $F_{ext}$. Note that this transfer function is in continuous time and we need a discretized version for a digital implementation on a computer. To get the discrete version, it is convenient to convert \eqref{eq:tf} first in the time domain:

\begin{align*}
K_d \Delta\dot{ p_e} + K_p{\Delta p_e}  =  F_{ext}  
\end{align*}
 
Then, if  we  employ Forward Euler $\dot{p_e} = (p_e(k)- p_e(k-1))dT^{-1}$ to approximate the derivative, we can get the following difference equation:

\begin{align*}
&K_d \frac{p_e(k)- p_e(k-1)}{dT}  + K_p \Delta p_e(k)  =  F_{ext}(k)  \\
&\Delta p_e(k) (K_d dT^{-1} + K_p ) - K_d \Delta p_e(k-1)dT^{-1} =  F_{ext}(k)\\
&\Delta p_e(k) =  (K_d dT^{-1} + K_p )^{-1} (F_{ext}(k) + K_d \Delta p_e(k-1)dT^{-1})
\end{align*}

where (k)and (k-1) refer to the actual and previous samples of the variables. \\

\textbf{2.2 Inverse Kinematics}\\
Now that we wrote a function to implement the admittance model, we still miss to implement the inverse kinematics function. To be able to convert the modified reference $\tilde{p_e}^d(k) = p_e^d(k) +  \Delta p_e(k)$  at each loop $k$ into a joint reference $q^d$. Note that, since our admittance model (composed of linear spring and damper)  involves only 3D vectors, and we have 6 DoFs in our robot, we will have redundancy, hence  infinite solutions to the inverse kinematics problem. To solve this we will reuse the postural task implementation described in LAB L1-2.4.\\


\textbf{2.3 - External push with a constant reference}\\
Now we are ready to test the implemented algorithm. Set  a constant joint reference $q_0$  for the robot to follow (that will correspond to a constant end-effector position) and set the admittance gains to $K_p = 1000I_{3\times3}$,  $K_d = 300I_{3\times3}$. We can how the controller works by applying an external force either in simulation (calling the function \codeword{applyForce()} after 5 seconds) or pushing manually (gently!) the end-effector (Important! keep always the E-stop in your hand to kill the robot in case some instability arise!). You should feel the robot deviating from the reference in the same direction of the force (we are setting a diagonal stiffness matrix), as if a spring is attached at the end-effector trying to push it back to the original position. 
Now try to reduce the stiffness gain to $K_p = 600I_{3\times3}$, in order to make the robot more ``soft''. You should feel that for the same force you are applying you are getting a bigger deflection (almost double).
Plot the signals of the end-effector position and force to evaluate the direction of the deflection is consistent with the force.

\textbf{2.4 - External push with a sinusoidal reference}
Let's now apply a sinusoidal reference to the robot joints  with amplitude $A= 0.1$ $rad$ and frequency $f = 0.2$ $Hz$, around the initial position $q_0$.

\begin{align*}
q^d(t) = q_0 + Asin(2\pi f t )
\end{align*} 

Now, apply the external disturbance, \textit{while} the robot is moving. You should see the end-effector deviating from the original trajectory in the direction of the pushing force. \\
 
 
\textbf{2.5 - Payload estimation.}\\
The final exercise of this lab will be to estimate a payload attached at the end effector in static conditions. We want to exploit the readings from the  joints that are stored in the variable \codeword{tau}. Employing the principle of Virtual works we can estimate the an external force applied at the end-effector via the transpose of the end-effector Jacobian. Note that we will have also gravity torques to take into consideration.
The derivation of the formula is the following, we start from the dynamic equation of the robot considering an external force $F$ is applied from the environment, and set the joint accelerations, velocity to zero:

\begin{align*}
g &= \tau  + J^TF \\
F &= -(J^T)^\dagger (\tau - g) 
\end{align*}

Note that you need to use the pseudo-inverse of the jacobian J to match dimensions.  Then the payload weight is:
\begin{align*}
m_p = -F_z / g 
\end{align*}

Finally, apply some filtering to take out the noise. 




\section{Potential fields for obstacle avoidance}
In this assignment you will be developing code to guide a robot from one location to another in a
2 dimensional configuration space using artificial potential fields. The figure below depicts a plot of
the energy surface associated with our sample environment and the state of the robot is modeled by
the red sphere which we can think of as rolling down the energy surface towards the goal location.
Create a \codeword{GradientBasedPlanner} to control the motion of the robot (i.e. velocity set-point).
The signature of the function is given below:

%\codeword{function route = GradientBasedPlanner (f, start coords, end coords, max its)}
%start coords : An array specifying the coordinates of the start location the first entry is
%the x coordinate and the second the y
%end coords : An array specifying the coordinates of the goal the first entry is the x coordinate
%and the second the y
%max its : The maximum number of iterations that should be tried by the planner

%
%We have two obstacles to avoid, we can exploit the additive property of potential field to cumulate their influences. 
%
%Additionally we want to keep also the joints (not only the end effector) away from the obstacles. We can therefore introduce contrel oints checking which is the closest point to the obstacle for each link. 
%
%To avoid the chance of our local planner to get stuck in local minima consider to produce some highe level goals (via points)
%
%
%In a cluttered environment, local minima can
%
%occur in the resultant potential field. This can lead to
%
%a stable positioning of the robot before reaching its
%
%goal. While local procedures can be designed to exit
%
%from such configurations, limitations for complex
%
%tasks will remain. This is because the approach has a
%
%local perspective of the robot environment
%
%Note that the potential field approach can be combined with any other the task space formulation  considering a inverse dynamics 
% that tracks the force generated from the field at each of the control points 
% 
% or at the velocity level.
%
%
%
%
%1. On every iteration the planner should update the position of the robot based on the gradient
%values contained in the arrays gx and gy. Note that the gradient is only giving informations on the direction (in the joint space) is up to you to limit the speed according to some heuristics.  Make sure you normalize the gradient vectors.
%Update the route by adding the new position of the robot to the end of the route array.
%Continue the same procedure until the distance between the robotâ€™s current position and the
%goal is less than 2.0 or the number of iterations exceeds the value contained in max its.

\end{document}